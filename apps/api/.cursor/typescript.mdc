---
alwaysApply: true
---
You are an expert in NestJS, Node.js, TypeScript, TypeORM/Prisma, Microservices, Clean Architecture, and Domain-Driven Design (DDD) principles.Code Style and StructureWrite concise, technical TypeScript code with accurate examples.Use functional and declarative programming patterns; avoid excessive use of classes where simple functions suffice (e.g., helper functions), but adhere to NestJS's class-based structure for Modules, Controllers, and Providers.Prefer iteration and modularization over code duplication.Use descriptive variable names with auxiliary verbs for booleans (e.g., $isLoading$, $hasError$).Structure files based on the Module/Feature pattern (e.g., $users/users.module.ts$).Within a feature module, separate concerns into Controllers, Services, Providers (Repositories, external clients), and DTOs/Entities.Naming ConventionsUse lowercase with dashes for directories (e.g., $src/auth/auth-strategy$).Use PascalCase for classes (e.g., $UsersModule$, $AuthService$).Use camelCase for methods and variables.Favor named exports for non-class helpers/constants.TypeScript UsageUse TypeScript for all code; prefer interfaces over types for defining object shapes, especially for DTOs and database entities.Avoid enums; use union types or maps/constants instead.Enforce strict type checking and utilize utility types where appropriate (e.g., $Partial$, $Omit$).Syntax and FormattingUse the function keyword for pure, non-class helper functions.Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.Prefer async/await over plain Promises with .then()/.catch().Architecture and DesignImplement the Service Layer pattern: Controllers should be thin and delegate business logic to Services. Services should handle the core logic.Utilize Repository Pattern (when using TypeORM/Prisma) within the service layer to abstract data access logic.Strictly separate Domain Logic (Entities, Domain Services) from Infrastructure (Database access, external HTTP calls).Use Pipes for request payload validation and transformation (e.g., $ValidationPipe$ with $class-validator$).Use Guards for authorization and authentication logic.Use Interceptors for request/response mapping, logging, and performance monitoring.Performance and ReliabilityUse Asynchronous operations throughout (Promises, async/await).Implement Graceful Shutdown for resilience.Use NestJS's built-in Caching Module for frequently accessed, slow data.Implement robust Logging using a dedicated library (e.g., Winston, Pino) integrated via the $LoggerService$.Key NestJS ConventionsUse DTOs (Data Transfer Objects) with $class-validator$ and $class-transformer$ for all incoming request bodies and query parameters.Adhere to SOLID principles, especially in the Service layer.For configuration, use the built-in $ConfigModule$ and environment variables.If building microservices, follow the Microservice Strategy (e.g., TCP, Redis, Kafka) as recommended by NestJS documentation.